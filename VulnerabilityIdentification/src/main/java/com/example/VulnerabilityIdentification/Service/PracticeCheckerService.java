package com.example.VulnerabilityIdentification.Service;

import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

@Service
public class PracticeCheckerService {

    public Map<String, List<String>> checkPractices(MultipartFile file, List<String> practices) throws IOException {
        Map<String, List<String>> result = new HashMap<>();
        List<String> lines = new ArrayList<>();

        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream()))) {
            String line;
            while ((line = br.readLine()) != null) {
                lines.add(line);
            }
        }

        for (String practice : practices) {
            List<String> violations = checkPractice(practice, lines);
            if (!violations.isEmpty()) {
                result.put(practice, violations);
            }
        }

        return result.isEmpty() ? Map.of("message", List.of("All practices are followed")) : result;
    }

    private List<String> checkPractice(String practice, List<String> lines) {
        List<String> violations = new ArrayList<>();

        switch (practice) {
            case "Strict Mode":
                boolean strictMode = lines.stream().anyMatch(line -> line.contains("\"use strict\""));
                if (!strictMode) {
                    violations.add("Strict mode not enabled");
                }
                break;

            case "Consistent Naming Conventions":
                checkConsistentNamingConventions(lines, violations);
                break;

            case "Declare Variables Properly":
                checkVariableDeclarations(lines, violations);
                break;

            case "Use Arrow Functions":
                checkArrowFunctions(lines, violations);
                break;

            case "Write Modular Code":
                // Add logic for checking modular code
                break;

            case "Avoid Eval":
                checkEvalUsage(lines, violations);
                break;

            case "Strict Comparison":
                checkStrictComparison(lines, violations);
                break;

            case "Avoid Null Values":
                checkNullValues(lines, violations);
                break;

            default:
                throw new IllegalArgumentException("Unknown practice: " + practice);
        }

        return violations;
    }

    private void checkConsistentNamingConventions(List<String> lines, List<String> violations) {
        // Implement logic for consistent naming conventions
    }

    private void checkVariableDeclarations(List<String> lines, List<String> violations) {
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.matches(".*\\bvar\\b.*")) {
                violations.add("In line " + (i + 1) + ": Variables should be declared using let or const instead of var");
            } else if (line.matches(".*\\blet\\b.*|.*\\bconst\\b.*") && !line.contains("=")) {
                violations.add("In line " + (i + 1) + ": Variables should be initialized when declared");
            }
        }
    }

    private void checkArrowFunctions(List<String> lines, List<String> violations) {
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.matches(".*function\\s*\\(.*\\).*")) {
                violations.add("In line " + (i + 1) + ": Consider using arrow functions instead of traditional functions");
            }
        }
    }

    private void checkEvalUsage(List<String> lines, List<String> violations) {
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.contains("eval(")) {
                violations.add("In line " + (i + 1) + ": Avoid using eval");
            }
        }
    }

    private void checkStrictComparison(List<String> lines, List<String> violations) {
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.contains("==") && !line.contains("===")) {
                violations.add("In line " + (i + 1) + ": Use strict comparison (===) instead of ==");
            }
        }
    }

    private void checkNullValues(List<String> lines, List<String> violations) {
        for (int i = 0; i < lines.size(); i++) {
            String line = lines.get(i);
            if (line.contains("null")) {
                violations.add("In line " + (i + 1) + ": Avoid using null values");
            }
        }
    }
}
